# Помощник составления технических опросов

Используется для разгрузки специалистов технической поддержки путём генерации конкретных вопросов из заранее заданных инструкций.

Таким образом пользователи могут сами получить ответы на необходимые вопросы пройдя простое тестирование.

## Документация

### Используемые инструменты

Фреймворк: Vue3 + script setup
Язык: Typescript
Сборщик: Vite
UI фреймворк: naive-ui
Линтеры: eslint + prettier
Работа с PDF: библиотека pdfmake

### Архитектура

Описание назначения папок и файлов.

![[ec-note-architecture.jpg]]

<div style="page-break-after: always;"></div>

### Детали реализации логики

#### Логика работы с данными схемы (schema.ts)

Файл экспортирует типы _ECNode_ и _ECNodeOptions_.
Доступ к переменной _schema_ которая должна содержать сериализованый файл схемы осуществляется путём использования _composable_ _useSchema_, а так же вспомогательных функций мутирующих состояние.

Схема данных представляет собой массив деревьев, где каждый элемент является деревом с максимальным уровнем вложенности 2. Т.е в каждом вопросе верхнего уровня может быть теоретически не ограниченное количество вариантов ответа и вложенных вопросов. Вложенные вопросы не могут иметь в себе вложенные вопросы.

Файл имеет следующие функции:

| Функция                                                   | Описание                                                                                                                                                                                                                                                                                                |
| --------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| useSchema                                                 | _Composable_ который предоставляет доступ к схеме                                                                                                                                                                                                                                                       |
| deleteNodeOption(node: ECNode, option: ECNodeOption)      | Удаляет из массива вариантов ответа в вопрос _node_ данный вариант _option_ и возвращает новый массив вариантов ответа. Не мутирует состояние схемы.                                                                                                                                                    |
| addNodeOption(node: ECNode, when: boolean)                | Добавляет вариант ответа в вопрос _node_, проставляет поле _\_id_ для внутреннего использования, текст варианта ответа остаётся пустым, условие при котором вариант ответа доступен равняется _when_.                                                                                                   |
| addNodeChild(node: ECNode, when: boolean)                 | Добавляет вопрос внутрь вопроса _node_, проставляет поле _\_id_ для внутреннего использования, текст вопроса остаётся пустым, условие при котором вариант ответа доступен равняется _when_, в вопрос добавляются два варианта ответа с пустым текстом вопроса и вариантами соответственно "Да" и "Нет". |
| addNode(nodes: node[])                                    | Добавляет вопрос верхнего уровня, проставляет поле _\_id_ для внутреннего использования, текст вопроса остаётся пустым, в вопрос добавляются два варианта ответа с пустым текстом вопроса и вариантами соответственно "Да" и "Нет".                                                                     |
| deleteNode(node: ECNode, parent: ECNode or null           | Удаляет данный вопрос _node_ из вопроса _parent_. Если _parent_ пуст, то удаляет вопрос верхнего уровня _node_.                                                                                                                                                                                         |
| setSchema(schemaToSet: { name: string; nodes: ECNode[] }) | Устанавливает схему данных.                                                                                                                                                                                                                                                                             |
| resetSchema()                                             | Обнуляет схему данных.                                                                                                                                                                                                                                                                                  |
| schemaToFile()                                            | Сохраняет текущую схему в файл используя библиотеку file-saver.                                                                                                                                                                                                                                         |
| isNodeCompleted(node: ECNode)                             | Возвращает _true_ или _false_ в зависимости от того завершено ли редактирование данного вопроса _node_.                                                                                                                                                                                                 |
| useEnrichedSchema()                                       | _Composable_ который предоставляет доступ к расширенной схеме в которой просчитаны корректные ID для вопросов и ответов вида: "1", "1.1", "1.1.1". А так же добавляет необходимые поля для сохранения вариантов ответа.                                                                                 |
| useSchemaAnswers(nodes: ECNode[])                         | _Composable_ который предоставляет доступ к сформированному массиву ответов которые используются при создании PDF-файла.                                                                                                                                                                                |

<div style="page-break-after: always;"></div>

#### Логика чата (chat.ts)

Чат состоит из массива сообщений, каждое сообщение имеет тип _Message_. Доступ к сообщениям осуществляется путём использования _composables_ _useMessages_ и _useMessagesControls_.

Поле _type_ у _Message_ может иметь следующие значения _MessageType_:

| Значение | Описание                                                                                                                                  |
| -------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| hello    | Используя _composable_ _useChatHello_ выводит вместо текста сообщения приветствие.                                                        |
| text     | Выводит поле _message_.                                                                                                                   |
| file     | Выводит иконку файла перед сообщением, а так же позволяет понять компоненту что нужно показать поле ввода файла.                          |
| chips    | Позволяет понять что текущее сообщение содержит в себе поле chips которое содержит в себе варианты ответа пользователя на сообщение бота. |

При первом запуске приложения два сообщения уже есть в массиве сообщений, это сообщение приветствия и предложение загрузить схему инструкции.

Файл имеет следующие функции:

| Фунция                                                                    | Описание                                                                                                                                      |
| ------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| useMessages                                                               | _Composable_ который предоставляет доступ к массиву сообщений и последнему сообщению.                                                         |
| useMessagesControls                                                       | _Composable_ который предоставляет функции для управления сообщениями.                                                                        |
| --- addMessage(message: Omit<Message, 'id'>)                              | Добавляет сообщение в чат, автоматически проставляет _id_ для внутреннего использования.                                                      |
| --- addMessages(messagesToAdd: Omit<Message, 'id'>[])                     | Добавляет несколько сообщений в чат, внутри использует функцию _addMessage_.                                                                  |
| --- addMessagePair({ toText: string; fromText: string; options?: any[] }) | Добавляет пару сообщений вида: бот / пользователь. Внутри использует функцию _addMessages_.                                                   |
| useChatHello                                                              | _Composable_ который позволяет зависимости от времени суток получать строки: "Добрый день!", "Доброе утро!", "Добрый вечер!", "Доброй ночи!". |

<div style="page-break-after: always;"></div>

#### Логки управления файлом схемы (file.ts)

Управление файлом состоит из методов сериализации и загрузки файла схемы используя файл для работы с данными схемы.

Состояние загрузки файла _FileState_:

| Значение | Описание                  |
| -------- | ------------------------- |
| nofile   | Файл не удалось загрузить |
| uploaded | Файл загружен успешно     |
| loading  | Файл загружается          |

Файл имеет следующие функции:

| Функция                            | Описание                                                                                                                                                  |
| ---------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| fileToJson(file: File)             | Сериализует данный функции файл в JSON формат для дальнейшего использования                                                                               |
| uploadSchema(file: UploadFileInfo) | Используется при загрузке файла, пытается сериализовать файл и если получается то сразу устанавливает схему, иначе отвечает что файл загрузить не удалось |

<div style="page-break-after: always;"></div>

#### Логика работы с pdf-файлами (pdf.ts)

Файл экспортирует типы _Answer_ и _Answers_ переменные которых необходимы для создания PDF-файла.

Файл имеет следующие функции:

| Функция                                   | Описание                                                                                                                                                                                                                                                                                               |
| ----------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| createPdf(name: string, answers: Answers) | Генерирует файл _name_ в который включены ответы на вопросы _answers_. Размер шрифта заголовка 16, размер шрифта вопроса 12, размер ответа на вопрос 11. Используемый шрифт Roboto. Функция ожидает увидеть в глобальной переменной _window_ поле pdfMake которое предоставляется библиотекой pdfmake. |

<div style="page-break-after: always;"></div>

### Детали реализации UI

#### Папка _utility/_

В папке находятся компоненты UI в которые вынесены часто повторяющийся код который могут использовать компоненты разных частей системы.

##### Компонент _ec-yes-no-group.vue_

Компонент реализует кнопки "Да" и "Нет" объединённые в группу. Так же предоставляется _slot_ по умолчанию в конце группы.

Доступные _props_:

| Prop  | Тип                            | Описание                                                        |
| ----- | ------------------------------ | --------------------------------------------------------------- |
| value | Boolean or undefined or null   | Значение _v-model:value_ которое указывает какая кнопка нажата. |
| size  | "small" or "medium" or "large" | Указывает какого размера будут кнопки "Да" и "Нет".             |
| show  | Boolean                        | Указывает нужно ли показывать кнопки, по умолчанию _true_.      |

##### Компонент _ec-heading.vue_

Компонент реализует заголовок по умолчанию для различных страниц приложения. Предоставляет _slot_ по умолчанию для текста заголовка.

##### Компонент _ec-file-upload.vue_

Компонент реализует поле для загрузки файла схемы.

Доступные _props_:

| Prop   | Тип     | Описание                                                                                                                        |
| ------ | ------- | ------------------------------------------------------------------------------------------------------------------------------- |
| big    | Boolean | Указывает на то что нужно показывать большое поле для файла, используется на странице загрузки анкеты.                          |
| small  | Boolean | Указывает на то что нужно показывать маленькое поле для файла, используется на странице чат-бота.                               |
| button | Boolean | Указывает на то что нужно показывать поле для загрузки файла в виде кнопки, используется на странице создания схемы инструкции. |

<div style="page-break-after: always;"></div>

#### transitions/

В папке находятся компоненты UI которые представляют собой различные используемые анимации в проекте.

<div style="page-break-after: always;"></div>

#### Папка _survey/_

В папке находятся компоненты которые реализуют заполнение анкеты в приложении.

##### Страница _pages/index.vue_

Страница реализует основную логику работы анкеты объединяя описанные ниже компоненты.

Изначально показывается [[#Компонент ec-heading vue]] и [[#Компонент ec-file-upload vue]]. После загрузки файла, схема данных обновлятся, и на странице отображается анкета.

Анкета состоит из [[#Компонент ec-survey-step vue]] в _slot_ по умолчанию которого передается:

- уведомление с призывом ответить на вопрос "Да" или "Нет"
- [[#Компонент ec-survey-options vue]] который далее рекурсивно может отобразить вложенные вопросы если они будут
- [[#Компонент ec-survey-controls vue]] который позволяет двигаться по анкете

По нажатию кнопки "Завершить" в [[#Компонент ec-survey-controls vue]] на скачивание отправляется PDF-файл с выбранными ответами на вопрос.

##### Компонент _ec-survey-controls.vue_

Компонент реализует кнопки для продвижения по анкете: "Назад", "Дальше", "Завершить".

Доступные _props_:

| Prop         | Тип    | Описание                                                     |
| ------------ | ------ | ------------------------------------------------------------ |
| current      | Number | Указывает текущий шаг прохождения анкеты.                    |
| total        | Number | Указывает сколько всего шагов в анкете.                      |
| disabledNext | Number | Указывает на то нужно ли сделать кнопку "Дальше" неактивной. |

##### Компонент _ec-survey-options.vue_

Компонент реализует отображение вариантов ответа в анкете.

Если в компонент передан _вариант ответа_, то компонент отображает _радио-кнопку_, иначе, если в компонент передан вложенный вопрос, то отображается [[#Компонент ec-survey-subnode vue]].

Доступные _props_:

| Prop | Тип    | Описание                            |
| ---- | ------ | ----------------------------------- |
| node | ECNode | Вложенный вопрос или вариант ответа |

##### Компонент _ec-survey-step.vue_

Компонент реализует отображение текущего шага. Предоставляет _slot_ по умолчанию для контента и _slot_ _title_ для заголовка.

| Prop | Тип    | Описание                             |
| ---- | ------ | ------------------------------------ |
| step | Number | Указывает номер шага, по умолчанию 0 |

##### Компонент _ec-survey-subnode.vue_

Отображает вложенный вопрос с вариантами ответа. Изначально показывает уведомление с призывом ответить на вопрос "Да" или "Нет", после ответа уведомление скрывается и показывается [[#Компонент ec-survey-options vue]].

Доступные _props_:

| Prop | Тип    | Описание         |
| ---- | ------ | ---------------- |
| node | ECNode | Вложенный вопрос |

<div style="page-break-after: always;"></div>

#### Папка _node/_

В папке находятся компоненты которые реализуют создание схемы инструкции.

##### Страница pages/create.vue

Страница реализует основную логику создания схемы инструкции. Объединяя описанные ниже компоненты.

Изначально показывает: [[#Компонент ec-heading vue]], кнопку сброса схемы, поле ввода названия схемы, кнопку добавления вопроса, [[#Компонент ec-file-upload vue]] для загрузки уже готовой схемы для редактирования.

Далее по мере добавления вопросов они отображаются используя [[#Компонент ec-node vue]]

##### Компонент _ec-node-add-option.vue_

Компонент показывает поле выбора поля _type_ для _node_. Варианты ответа: "Вариант ответа", "Вопрос".

Если у переданный _node_ это вложенный вопрос, то варианты ответа в поле выбора ограничиваются до "Вариант ответа".

В зависимости от выбора в _node_ создается соответственно вопрос или вариант ответа, используя функции _addNodeChild_ и _addNodeOption_.

Доступные _props_:

| Prop | Тип     | Описание                                                                   |
| ---- | ------- | -------------------------------------------------------------------------- |
| node | ECNode  | Вопрос верхнего уровня или вложенный вопрос                                |
| when | Boolean | Определяет при каком варианте ответа на вопрос добавлять выбранный элемент |

##### Компонент _ec-node-option.vue_

Компонент отображает либо [[#Компонент ec-yes-no-group vue]] если параметр _type_ у _option_ равен _"option"_, иначе, если равен _"node"_ отображает [[#Компонент ec-node vue]].

Доступные _props_:

| Prop   | Тип          | Описание                                                                                                       |
| ------ | ------------ | -------------------------------------------------------------------------------------------------------------- |
| node   | ECNode       | Вопрос верхнего уровня или вложенный вопрос в котором находится выбранный вложенный вопрос или вариант ответа. |
| option | ECNodeOption | Вариант ответа который нужно отобразить.                                                                       |

##### Компонент _ec-node.vue_

Компонент отображает вопрос для редактирования. Является рекурсивным. Отображает:

- номер (_id_) вопроса, если он является вопросом верхнего уровня
- [[#Компонент ec-yes-no-group vue]] для установки ответа на вопрос если компонент является вложенным вопросом
- [[#Компонент ec-node-option vue]] для каждой опции существующей в вопросе, если опции существуют.

Доступные _props_:

| Prop    | Тип            | Описание                                                     |
| ------- | -------------- | ------------------------------------------------------------ |
| node    | ECNode         | Вопрос верхнего уровня или вложенный вопрос.                 |
| parent  | ECNode or null | Родитель вопроса, если такой есть.                           |
| isFirst | Boolean        | Указывает что этот вопрос является вопросом верхнего уровня. |

<div style="page-break-after: always;"></div>

#### Папка _chat/_

В папке находятся компоненты которые реализуют работу чат-бота в приложении.

##### Страница _pages/chat.vue_

Страница отвечает за функциональность чат-бота.

Изначально отображается: заголовок, поле для сообщений в котором уже присутствуют два сообщения уже существующих в массиве сообщений на момент начальной загрузки страницы, и [[#Компонент ec-chat-toolbar vue]] который предлагает загрузить файл.

После загрузки файла вызывается функция _handleFileChange_, от пользователя исходит сообщение с именем файла, а бот предлагает выбрать вопрос с которого необходимо начать инструкцию. При выборе вопроса все вопросы которые были до выбранного отбрасываются навсегда с помощью функции _buildSchemaFromId_.

Далее идёт описание функции _handleChipClick(chip: any, event: Event)_ которая обрабатывает нажатие на кнопки внутри [[#Компонент ec-chat-toolbar vue]].

---

- Анимируем нажатую кнопку вынося её вправо и вверх с постепенным затуханием.
- Выключаем все доступные кнопки что бы предотвратить двойной клик.

---

- Проверяем если _chip.type_ равен "new-schema", то сбрасываем состояние чата не удаляя сообщения и предлагаем загрузить схему ещё раз, начиная цикл обработки заново
- Проверяем если переменная обьявленная в начале файла _questions_ не имеет значения, то из этого мы понимаем что файл был только-что загружен, и используя функцию _useQuestions(nodes: ECNode[])_ формируем список вопросов. Список вопросов формирется путём выпрямления дерева для оптимизации работы с ним
- Выводим сообщение от пользователя с выбранным вопросом с которого нужно начать заполнение схемы, и выходим из функции

---

- Если переменная _questions_ обьявлена, то проверяем если _chip.type_ равен "answer" то значит что пользователь ответил на вопрос или выбрал вариант ответа
- Выставляем для вопроса выбранный ответ, и фильтруем _questions_ что бы исключить уже не релевантные записи используя функцию _filterQuestions_.
- Проверяем если есть текущем вопросе релевантные опции, то значит мы отвечаем на вопрос с вариантами ответа, предлагаем пользователю выбрать один из них
- Иначе, значит что мы задаем пользователю вопрос, и даем ему варианты ответа "Да" или "Нет"

---

- Если _chip.type_ не равен "answer", то значит что мы закончили отвечать на вопрос верхнего уровня
- Выбираем следующий вопрос с помощью функции _getNextQuestionIndex_
- Если функция возвращает -1, то значит что вопросы верхнего уровня закончились, опрос завершён, и мы можем формировать PDF-файл
- Формируем ответы на вопросы из перменной _questions_ (так как она другого формата, то функция сделанная для формирования ответов на вопросы нам не подходит)
- Отправляем сформированный PDF-файл на скачивание и предлагаем пользователю загрузить новый файл схемы

---

- Если функция _getNextQuestionIndex_ возвращает значение отличное от -1, то значит что в схеме ещё остались вопросы
- Предлагаем пользователю ответить на следующий вопрос

<div style="page-break-after: always;"></div>

##### Компонент _ec-chat-message.vue_

В зависимости от перданных _props_ показывает сообщение нужного вида.

Доступные _props_:

| Prop    | Тип         | Описание                                             |
| ------- | ----------- | ---------------------------------------------------- |
| avatar  | Boolean     | Указывает нужно ли отображать аватар над сообщением. |
| message | String      | Текст сообщения для отображения                      |
| type    | MessageType | Тип сообщения для отображения                        |
| from    | Boolean     | Указывает что сообщение от бота                      |
| to      | Boolean     | Указывает что сообщение от пользователя              |

##### Компонент _ec-chat-toolbar.vue_

Отвечает за нижнее меню чата, в случае если "status" равен "file" показывает поле для загрузки файла схемы инструкции, иначе, если "status" равен "chips", то предоставляет _slot_ по умолчанию.

Доступные _props_:

| Prop   | Тип               | Описание                                                                                 |
| ------ | ----------------- | ---------------------------------------------------------------------------------------- |
| status | "file" or "chips" | Указывает отображать поле для загрузки файла, или _slot_ для отображение кнопок вопросов |

##### Компонент _ec-chat.vue_

Отображает переданные сообщения _messages_ с помощью [[#Компонент ec-chat-message vue]].

Доступные _props_:

| Prop     | Тип      | Описание                  |
| -------- | -------- | ------------------------- |
| messages | Messages | Сообщения для отображения |

<div style="page-break-after: always;"></div>

### Тестирование

Далее представлена поэтапная программа тестирование различных частей системы с описанием ожидаемых промежуточных результатов в ходе работы. По завершению выполнения описанных ниже инструкций, если промежуточные результаты совпадают с описанными в тестировании, можно считать, что весь заявленный функционал реализован.

Для выполнения некоторых действий может понадобиться прикреплённый файл "example.json"

<div style="page-break-after: always;"></div>

#### Тестирование чат-бота

1. Зайти на тестовую страницу https://newfox79.github.io/ec-builder/#/chat
2. Нажать на загрузку файла снизу экрана и выбрать файл "example.json", или переместить его в поле для загрузки файла снизу экрана
3. Нажать на синюю кнопку "Есть номер лота?"
4. Нажать на кнопку "Да"
5. Нажать на кнопку "Нет"
6. Нажать на кнопку "Во внеплановой закупке один лот"
7. Нажать на кнопку "Нет"
8. Нажать на кнопку "Другой способ"
9. Нажать на кнопку "Да"
10. Нажать на кнопку "Нет"
11. Нажать на кнопку "Несколько ставок НДС"
12. Сравнить скачанный файл "Варианты Заявки на закупку.pdf" с приложенным файлом result-1.pdf, они должны быть идентичны
13. (Опционально) Нажать на кнопку "Да"
14. (Опционально) Повторить пункты 2-12.

<div style="page-break-after: always;"></div>

#### Тестирование анекты

1. Зайти на тестовую страницу https://newfox79.github.io/ec-builder/#/
2. Нажать на загрузку файла снизу экрана и выбрать файл "example.json", или переместить его в поле для загрузки файла снизу экрана
3. Возле вопроса "У заявки фиксированная сумма?" нажать на кнопку "Да"
4. Выбрать пункт "1.1 Фиксированная сумма для группы заявок"
5. Нажать на синюю кнопку "Дальше"
6. Возле вопроса "Есть номер лота?" нажать на кнопку "Нет"
7. Выбрать пункт "2.4 Биржевая закупка"
8. Нажать на синюю кнопку "Дальше"
9. Возле вопроса "Договор с НДС?" нажать на кнопку "Да"
10. Возле вопроса "Ставка НДС будет одна?" нажать на кнопку "Да"
11. Выбрать пункт "3.1.1 Ставка НДС одна"
12. Нажать на синюю кнопку "Завершить"
13. Сравнить скачанный файл "Варианты Заявки на закупку.pdf" с приложенным файлом result-2.pdf, они должны быть идентичны
14. (Опционально) Повторить пункты 2-12

<div style="page-break-after: always;"></div>

#### Тестирование создания схемы

1. Зайти на тестовую страницу https://newfox79.github.io/ec-builder/#/create
2. В поле ввода "Название" ввести _Тестовая схема_
3. Возле серого квадрата с цифрой 1, найти поле ввода "Введите вопрос", ввести _Тестовый вопрос 1_
4. Найти синюю кнопку с иконкой плюса справа от редактируемого поля ввода, нажать на неё
5. Из выпадающего списка выбрать "Вопрос"
6. В конце опций должен был появиться пустой вопрос с двумя вариантами ответов
7. После поля ввода _Тестовый вопрос 1_ найти следующее поле ввода
8. Справа найти черную иконку на белом фоне с изображением корзины
9. Нажать на корзину
10. Опция должна была удалиться
11. Слева от следующего поля ввода нажать на кнопку "Да", а в поле ввода ввести _Вариант ответа 1_
12. Найти следующее поле ввода в котором написано "Введите вопрос"
13. Справа от него нажать на кнопку "Нет", а в поле ввода ввести _Вложенный вопрос 1_
14. Найти следующее поле ввода и ввести _Вариант ответа 1.1_
15. Найти следующее поле ввода и ввести _Вариант ответа 1.2_
16. Нажать на синюю кнопку "Добавить вопрос"
17. Должен был добавиться пустой вопрос
18. Справа от поля ввода добавленного вопроса с текстом "Введите вопрос", найти черную иконку на белом фоне с изображением корзины, нажать на неё
19. Вопрос должен был удалиться
20. Нажать на зелёную кнопку "Скачать схему"
21. Должен был скачаться файл "Тестовая схема.json"
22. Нажать на кнопку "Сбросить" справа от заголовка "Создание схемы"
23. Название схемы и сама схемы должны были удалиться
24. Найти кнопку "Загрузить схему" рядом с синей кнопкой "Добавить вопрос" снизу от поля ввода "Название"
25. Нажать на неё и загрузить скачанный файл в пунктах 20-21
26. Проверить что вывелась та же схема что и до пунктов 22-23
27. (Опционально) проверить созданную схему в чат-боте и анкете, ориентируясь на пункты описанные в соответствующих главах тестирования
